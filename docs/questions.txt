
cs246 project

# monopoly
cs246 project



Would the observer pattern be good pattern to use when implementing gameboard?

Yes, the following are examples where the observer pattern could be used. 

We will have a textDisplay Class which will handle printing to the screen. This textdisplay class will print out each property and all it's printable attributes. When a property changes state, it will notify this text display class to print out the change in state. This is an example of using the observer pattern, where the text display cells are being notified to print out correct values when the state of a cell has been changed.

We will have a Board class which handles interactions with the board. This board class will have a linked list of properties. 
We will also implement a Property Class. Our properties will have an array that is the length of the number of players. The values in our array will be 1 or 0, which will be our 2 states. Either the player represented by the index is on the property (1) or not (0).

We can make properties be observers of adjacent properties to efficiently control player movement. When a player, named player x, needs to move n spaces, we will keep track of how many spaces they have already moved. The property player x is on after the roll will change state to not contain the player, and notify it's adjacent property to change state. This adjacent property now changed state to contain the player. If the player has not moved n spaces, it will change state again to remove the player from itself and notify the next property to contain the player. This will happen n times until player x has moved n spaces. This is another example of each property using the observer pattern to notify it's adjacent properties to change state. 

Question: What could you do to ensure there are never more than 4 Roll Up the Rim cups? 
Keep a field called "numberRollUpRimCups" that keeps track of how many cups there are out. Do not give roll up rim cups if that number is 0.

Alternatively, you can make a singleton class called timscupdispenser that returns 1 or  when you call it to give you a tims cup. Any time a tims cup is used you would return it to the dispencer.  

Question: Suppose we wanted to model SLC and Needles Hall more closely to Chance and Community Chest cards. Is there a suitable design pattern you could use? How would you use it?

We could implement a doubly - linked list(or array) with pointers to community chest or chance cards. We will generate the cards when the game starts based on the probability table given. We will have a pointer to the top card. If a player lands on a square that requires a community chest, or chance card, they will take the top card, take the action, and that card will notify the card next to it to become the top card. This would be an example of the observer pattern, wherein the top card changes state to not be the top card, and the card underneath it changes state to be the top card.

In the array implementation, all subsequent cards will move forward one index in the array, and the old top card becomes the top card.
In the doubly-linked list implementation, the top card observes the bottom card, and the card underneath it. Once the top card has been used, it notifies the card below it to become the top card, then it becomes the bottom card. This implementation mimics the observer pattern design pattern.

Alternatively, you can define a card class who is a friend of the player class. Each specific type of card would be a child class of the card class and have its own action member that subjects the player to some action unique to the card type. You can then make a deck of these cards by making an array of card pointers and deallocating it with a random index. The probablility distrobution can be manipulated by filling the array with the desired number of pointers to the same card.

Question: Can the decorator pattern be used to generalize improvements.
Yes improvement classes which inherit from the property class and decorate properties can be made. Each improvement would have a pointer to the next property, a name, a pointer to a function that takes in and returns an int, and a getTuition method that calls the getTuition method on the next property then applies function to it and returns the result. The function in question would be specific to each property object.



